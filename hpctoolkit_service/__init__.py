"""This module defines and registers the example gym environments."""
from pathlib import Path

from compiler_gym.util.runfiles_path import runfiles_path, site_data_path

HPCTOOLKIT_PY_SERVICE_BINARY: Path = runfiles_path(
    "examples/hpctoolkit_service/service_py/compiler_gym-example-service-py"
)

BENCHMARKS_PATH: Path = runfiles_path(
    "examples/hpctoolkit_service/benchmarks/cpu-benchmarks"
)

HPCTOOLKIT_HEADER: Path = runfiles_path(
    "/home/dx4/tools/CompilerGym/compiler_gym/third_party/hpctoolkit/header.h"
)

from compiler_gym.envs.compiler_env import CompilerEnv
from compiler_gym.spaces import Commandline, CommandlineFlag
from typing import cast, List, Union
import os
import shutil
import gym


class HPCToolkitCompilerEnv(CompilerEnv):
    """
    The below functions are copied from LlvmEnv
    """

    def get_command_line_flags_from_named_discrete_space(self):
        commandline_flags = [CommandlineFlag(f, f, f) for f in self.action_space.names]
        return commandline_flags

    def create_commandline_space(self):
        return Commandline(self.get_command_line_flags_from_named_discrete_space(),
                           self.action_space.name)

    def commandline(  # pylint: disable=arguments-differ
            self, textformat: bool = False
    ) -> str:
        """Returns an LLVM :code:`opt` command line invocation for the current
        environment state.

        :param textformat: Whether to generate a command line that processes
            text-format LLVM-IR or bitcode (the default).
        :returns: A command line string.
        """
        # For some reason, action space won't be changed to CommandlineSpace.
        # We're manually creating Commandline object.
        # This was the previous implementation that doesn't work.
        # command = cast(Commandline, self.action_space).commandline(self.actions)
        command = self.create_commandline_space()
        # print(cast(Commandline, self.action_space))
        command = command.commandline(self.actions)
        if textformat:
            return f"opt {command} input.ll -S -o output.ll"
        else:
            return f"opt {command} input.bc -o output.bc"

    def commandline_to_actions(self, commandline: str) -> List[int]:
        """Returns a list of actions from the given command line.

        :param commandline: A command line invocation, as generated by
            :meth:`env.commandline() <compiler_gym.envs.LlvmEnv.commandline>`.
        :return: A list of actions.
        :raises ValueError: In case the command line string is malformed.
        """
        # Strip the decorative elements that LlvmEnv.commandline() adds.
        if not commandline.startswith("opt "):
            raise ValueError(f"Invalid commandline: `{commandline}`")
        if commandline.endswith(" input.ll -S -o output.ll"):
            commandline = commandline[len("opt "): -len(" input.ll -S -o output.ll")]
        elif commandline.endswith(" input.bc -o output.bc"):
            commandline = commandline[len("opt "): -len(" input.bc -o output.bc")]
        else:
            raise ValueError(f"Invalid commandline: `{commandline}`")
        return self.create_commandline_space().from_commandline(commandline)

    # def fork(self):
    #     ret = super().fork()
    #     return ret

    def write_bitcode(self, path: Union[Path, str]) -> Path:
        """Write the current program state to a bitcode file.

        :param path: The path of the file to write.
        :return: The input :code:`path` argument.
        """
        path = Path(path).expanduser()
        # FIXME vi3: We don't support this observation spaces.
        #   I guess we could just return the pickled content of the bitcode file
        tmp_path = self.observation["BitcodeFile"]
        try:
            shutil.copyfile(tmp_path, path)
        finally:
            os.unlink(tmp_path)
        return path


from compiler_gym.util.registration import register
from utils import HPCTOOLKIT_PY_SERVICE_BINARY
from hpctoolkit_service.agent_py.rewards import perf_reward
from compiler_gym.envs.llvm.datasets import (
    AnghaBenchDataset,
    BlasDataset,
    CBenchDataset,
    CBenchLegacyDataset,
    CBenchLegacyDataset2,
    CHStoneDataset,
    CsmithDataset,
    NPBDataset,
)

from hpctoolkit_service.agent_py.datasets import hpctoolkit_dataset
from hpctoolkit_service.agent_py.datasets import poj104_dataset

from compiler_gym.util.runfiles_path import site_data_path

# register perf session
register(
    id="perf-v0",
    # Vladimir: llvm auto tuners need this class. AFAIK, for dumping the opt flags combination.
    entry_point=HPCToolkitCompilerEnv,
    kwargs={
        "service": HPCTOOLKIT_PY_SERVICE_BINARY,
        "rewards": [perf_reward.Reward()],
        "datasets": [
            CBenchDataset(site_data_path("llvm-v0")),
            CsmithDataset(site_data_path("llvm-v0")),
            hpctoolkit_dataset.Dataset(),
            poj104_dataset.Dataset(),
        ],
    },
)


def make(id: str, **kwargs):
    """Equivalent to :code:`compiler_gym.make()`."""
    import compiler_gym
    return compiler_gym.make(id, **kwargs)
