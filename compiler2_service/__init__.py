"""This module defines and registers the example gym environments."""
from pathlib import Path

from compiler_gym.util.runfiles_path import runfiles_path, site_data_path

from compiler_gym.envs.compiler_env import CompilerEnv
from compiler_gym.spaces import Commandline, CommandlineFlag
from compiler_gym.service.proto import Space, proto_to_action_space, CommandlineSpace
from compiler_gym.wrappers import CompilerEnvWrapper
from typing import cast, List, Union, Optional
import os
import shutil
import sys
import logging
import signal

def convert_commandline_space_message(message: CommandlineSpace) -> Commandline:
    # Copied from CompilerGym and adapted.
    return Commandline(
        items=[
            CommandlineFlag(name=name, flag=name, description="")
            for name in message.space.named_discrete.name
        ],
        name=None,
    )


class HPCToolkitCompilerEnv(CompilerEnv):
    """
    The below functions are copied from LlvmEnv
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if len(self.service.action_spaces) != 1:
            raise Exception("Vladimir: Not supporting more than one")
        # Vladimir: I need to force conversion to CommandlineSpace
        self.action_spaces = [
            convert_commandline_space_message(self.service.action_spaces[0])
        ]
        # Vladimir: Force action_space initialization
        # Without this it might not work
        self.action_space = ""

    def commandline(  # pylint: disable=arguments-differ
            self, textformat: bool = False
    ) -> str:
        """Returns an LLVM :code:`opt` command line invocation for the current
        environment state.

        :param textformat: Whether to generate a command line that processes
            text-format LLVM-IR or bitcode (the default).
        :returns: A command line string.
        """
        # For some reason, action space won't be changed to CommandlineSpace.
        # We're manually creating Commandline object.
        # This was the previous implementation that doesn't work.
        command = cast(Commandline, self.action_space).commandline(self.actions)
        if textformat:
            return f"opt {command} input.ll -S -o output.ll"
        else:
            return f"opt {command} input.bc -o output.bc"

    def commandline_to_actions(self, commandline: str) -> List[int]:
        """Returns a list of actions from the given command line.

        :param commandline: A command line invocation, as generated by
            :meth:`env.commandline() <compiler_gym.envs.LlvmEnv.commandline>`.
        :return: A list of actions.
        :raises ValueError: In case the command line string is malformed.
        """
        # Strip the decorative elements that LlvmEnv.commandline() adds.
        if not commandline.startswith("opt "):
            raise ValueError(f"Invalid commandline: `{commandline}`")
        if commandline.endswith(" input.ll -S -o output.ll"):
            commandline = commandline[len("opt "): -len(" input.ll -S -o output.ll")]
        elif commandline.endswith(" input.bc -o output.bc"):
            commandline = commandline[len("opt "): -len(" input.bc -o output.bc")]
        else:
            raise ValueError(f"Invalid commandline: `{commandline}`")
        return self.action_space.from_commandline(commandline)

    # def fork(self):
    #     ret = super().fork()
    #     return ret

    def write_bitcode(self, path: Union[Path, str]) -> Path:
        """Write the current program state to a bitcode file.

        :param path: The path of the file to write.
        :return: The input :code:`path` argument.
        """
        path = Path(path).expanduser()
        # FIXME vi3: We don't support this observation spaces.
        #   I guess we could just return the pickled content of the bitcode file
        tmp_path = self.observation["BitcodeFile"]
        try:
            shutil.copyfile(tmp_path, path)
        finally:
            os.unlink(tmp_path)
        return path

import pdb

class HPCToolkitCompilerEnvLoggingWrapper(CompilerEnvWrapper):
    def __init__(self, env):
        super().__init__(env)
        self.log_list = []
        self.log_path = self.create_log_dir(self.env.spec.id)
        self.prepare_header(self.log_path)
        self.prev_observation = None
        signal.signal(signal.SIGINT, self.log_to_file)


    def multistep(
        self,
        actions,
        observation_spaces=None,
        reward_spaces=None,
        **kwargs
    ):
        logging.info("*******  **************** Apply multi-step ***********************")
        

        observation, reward, done, info = super().multistep(actions, observation_spaces, reward_spaces, **kwargs)
    
        # Log only when you have 1 action 
        if len(actions) == 1 and observation:     
            # Log only if you have previous_observation
            if type(self.prev_observation) != type(None):    
                self.log_list.append(
                    self.format_log(
                        benchmark_uri=str(self.env.benchmark.uri),
                        prev_observation=self.prev_observation[0].flat[:],
                        observation=observation[0].flat[:],
                        action=self.env.action_space.names[actions[0]],
                        prev_actions=self.env.commandline(),
                        reward=reward[0] if not isinstance(reward, float) else reward
                    )
                )

            self.prev_observation = observation[0]


        return observation, reward, done, info

    # def observation(self, observation):
    #     return np.concatenate((observation, self.histogram)).astype(
    #         self.env.observation_space.dtype
    #     )

    def close(self):
        # Dump current content of the log_list to a file.
        self.log_to_file()
        super().close()

    def __del__(self):
        # In case someone forgot to call close for the env.
        self.log_to_file()

    @staticmethod
    def create_log_dir(env_name):
        from datetime import datetime

        root = os.getenv('COMPILER2_ROOT')
        assert root
        timestamp = datetime.now().strftime("%Y-%m-%d/%H-%M-%S")
        log_dir = "/".join([root, "results", "random-" + env_name, timestamp, str(os.getpid())])
        os.makedirs(log_dir)

        # Put executed command to the log 
        with open(log_dir + "/command.txt", "w") as txt:
            txt.write(" ".join(sys.argv))


        return log_dir

    @staticmethod
    def list2str(l):
        return " ".join([str(x) for x in l])

    @staticmethod
    def format_log(
        benchmark_uri: str, 
        prev_observation: list, 
        observation: list, 
        action: str, 
        prev_actions: str, 
        reward: float
        ):
        prev_obs_str =  HPCToolkitCompilerEnvLoggingWrapper.list2str(prev_observation)
        obs_str = HPCToolkitCompilerEnvLoggingWrapper.list2str(observation)
        return [benchmark_uri,
                prev_obs_str,
                obs_str,
                action,
                prev_actions,
                str(reward)]

    def prepare_header(self, log_path):
        with open(log_path + "/results.csv", "w") as csv:
            csv.write("BenchmarkName,State,NextState,Action,CommandLine,Reward\n")

    def log_to_file(self):
        # No need to dump empty log_list
        if not self.log_list:
            return
        with open(self.log_path + "/results.csv", "a") as csv:
            for line in self.log_list:
                csv.write(",".join(line) + "\n")

        print("\nResults written to: ", self.log_path + "/results.csv\n")
        # Clear the content
        self.log_list.clear()


from compiler_gym.util.registration import register
from compiler2_service.paths import COMPILER2_SERVICE_PY
from compiler2_service.agent_py.rewards import perf_reward, runtime_reward
from compiler_gym.envs.llvm.datasets import (
    AnghaBenchDataset,
    BlasDataset,
    CBenchDataset,
    CBenchLegacyDataset,
    CBenchLegacyDataset2,
    CHStoneDataset,
    CsmithDataset,
    NPBDataset,
)

from compiler2_service.agent_py.datasets import (
    hpctoolkit_dataset,
    poj104_dataset,
    poj104_dataset_small,
)

from compiler_gym.util.runfiles_path import site_data_path


# register perf session
def register_env():
    register(
        id="compiler2-v0",
        # Vladimir: llvm auto tuners need this class. AFAIK, for dumping the opt flags combination.
        entry_point=HPCToolkitCompilerEnv,
        kwargs={
            "service": COMPILER2_SERVICE_PY,
            "rewards": [
                perf_reward.RewardTensor(),
                # runtime_reward.RewardTensor()
            ],
            "datasets": [
                CBenchDataset(site_data_path("llvm-v0")),
                CsmithDataset(site_data_path("llvm-v0")),
                CHStoneDataset(site_data_path("llvm-v0")),
                hpctoolkit_dataset.Dataset(),
                poj104_dataset.Dataset(),
                poj104_dataset_small.Dataset()
            ],
        },
    )
register_env()

def make(id: str, **kwargs):
    """Equivalent to :code:`compiler_gym.make()`."""
    import compiler_gym
    return compiler_gym.make(id, **kwargs)


def make_log_env(id, **kwargs):
    return HPCToolkitCompilerEnvLoggingWrapper(make(id, **kwargs))
