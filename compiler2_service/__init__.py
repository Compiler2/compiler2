"""This module defines and registers the example gym environments."""
from importlib.metadata import entry_points
from pathlib import Path

from compiler_gym.util.runfiles_path import runfiles_path, site_data_path

from compiler_gym.envs.compiler_env import CompilerEnv
from compiler_gym.spaces import Commandline, CommandlineFlag
from compiler_gym.service.proto import CommandlineSpace
from compiler_gym.wrappers import CompilerEnvWrapper
from typing import cast, List, Union, Optional
import os
import shutil
import sys
import logging
import signal
import pickle
import pdb
import pandas as pd
import copy


def convert_commandline_space_message(message) -> Commandline:
    # Copied from CompilerGym and adapted.
    return Commandline(
        items=[
            CommandlineFlag(name=name, flag=name, description="")
            for name in message.space.named_discrete.name
        ],
        name=None,
    )


class HPCToolkitCompilerEnv(CompilerEnv):
    """
    The below functions are copied from LlvmEnv
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if len(self.service.action_spaces) != 1:
            raise Exception("Vladimir: Not supporting more than one")
        # Vladimir: I need to force conversion to CommandlineSpace
        self.action_spaces = [
            convert_commandline_space_message(self.service.action_spaces[0])
        ]
        # Vladimir: Force action_space initialization
        # Without this it might not work
        self.action_space = ""

    def commandline(  # pylint: disable=arguments-differ
            self, textformat: bool = False
    ) -> str:
        """Returns an LLVM :code:`opt` command line invocation for the current
        environment state.

        :param textformat: Whether to generate a command line that processes
            text-format LLVM-IR or bitcode (the default).
        :returns: A command line string.
        """
        # For some reason, action space won't be changed to CommandlineSpace.
        # We're manually creating Commandline object.
        # This was the previous implementation that doesn't work.
        command = cast(Commandline, self.action_space).commandline(self.actions)
        if textformat:
            return f"opt {command} input.ll -S -o output.ll"
        else:
            return f"opt {command} input.bc -o output.bc"

    def commandline_to_actions(self, commandline: str) -> List[int]:
        """Returns a list of actions from the given command line.

        :param commandline: A command line invocation, as generated by
            :meth:`env.commandline() <compiler_gym.envs.LlvmEnv.commandline>`.
        :return: A list of actions.
        :raises ValueError: In case the command line string is malformed.
        """
        # Strip the decorative elements that LlvmEnv.commandline() adds.
        if not commandline.startswith("opt "):
            raise ValueError(f"Invalid commandline: `{commandline}`")
        if commandline.endswith(" input.ll -S -o output.ll"):
            commandline = commandline[len("opt "): -len(" input.ll -S -o output.ll")]
        elif commandline.endswith(" input.bc -o output.bc"):
            commandline = commandline[len("opt "): -len(" input.bc -o output.bc")]
        else:
            raise ValueError(f"Invalid commandline: `{commandline}`")
        return self.action_space.from_commandline(commandline)

    # def fork(self):
    #     ret = super().fork()
    #     return ret

    def write_bitcode(self, path: Union[Path, str]) -> Path:
        """Write the current program state to a bitcode file.

        :param path: The path of the file to write.
        :return: The input :code:`path` argument.
        """
        path = Path(path).expanduser()
        # FIXME vi3: We don't support this observation spaces.
        #   I guess we could just return the pickled content of the bitcode file
        tmp_path = self.observation["BitcodeFile"]
        try:
            shutil.copyfile(tmp_path, path)
        finally:
            os.unlink(tmp_path)
        return path


class HPCToolkitCompilerEnvWrapper(CompilerEnvWrapper):
    def __init__(self, env, logging=False):
        super().__init__(env)
        self.logging = logging
        self.log_list = []
        self.prev_observation = None
        try:
            signal.signal(signal.SIGINT, self.log_to_file)
        except Exception:
            print("Problem while registering the CTRL+C event")
            # FIXME: See what to do when multiple threads are running within the same process.
            import traceback
            traceback.print_exc()

    def step(  # pylint: disable=arguments-differ
        self,
        action,
        seek = False,
        observation_spaces = None,
        reward_spaces = None,
        observations = None,
        rewards = None,
    ):
        if observations is not None:
            logging.warn(
                "Argument `observations` of CompilerEnv.step has been "
                "renamed `observation_spaces`. Please update your code",
                category=DeprecationWarning,
            )
            observation_spaces = observations
        if rewards is not None:
            logging.warn(
                "Argument `rewards` of CompilerEnv.step has been renamed "
                "`reward_spaces`. Please update your code",
                category=DeprecationWarning,
            )
            reward_spaces = rewards
        return self.multistep(  actions=[action], 
                                seek=seek, 
                                observation_spaces=observation_spaces, 
                                reward_spaces=reward_spaces)


    def multistep(
        self,
        actions,
        seek=False,
        observation_spaces=None,
        reward_spaces=None,
        **kwargs
    ):
        logging.info("*******  **************** Apply multi-step ***********************")

        observation, reward, done, info = super().multistep(actions, observation_spaces, reward_spaces, **kwargs)
        # Log only when you have 1 action 
        if self.logging and len(actions) == 1 and observation:     
            # Log only if you have previous_observation
            if type(self.prev_observation) != type(None) and info.get('action_had_no_effect') == False:
                logging.critical(f"Action = {actions[0]}, No_effect = {info.get('action_had_no_effect')}, reward = {reward[0]}")
                self.log_list.append(
                    self.format_log(
                        benchmark_uri=str(self.env.benchmark.uri),
                        observation_names = observation_spaces,
                        prev_observation=self.prev_observation,
                        observation=observation,                        
                        action=self.env.action_space.names[actions[0]],
                        prev_actions=self.env.commandline(),
                        reward=reward[0] if not isinstance(reward, float) else reward,                        
                    )
                )
            self.prev_observation = copy.deepcopy(observation)

        if seek:
            self.env.actions = self.env.actions[:-len(actions)]

        return observation, reward, done, info

    # def observation(self, observation):
    #     return np.concatenate((observation, self.histogram)).astype(
    #         self.env.observation_space.dtype
    #     )

    def close(self):
        # Dump current content of the log_list to a file.
        self.log_to_file()
        super().close()

    def __del__(self):
        # In case someone forgot to call close for the env.
        self.log_to_file()

    @staticmethod
    def create_log_dir(env_name):
        from datetime import datetime

        root = os.getenv('COMPILER2_ROOT')
        assert root
        timestamp = datetime.now().strftime("%Y-%m-%d/%H-%M-%S")
        log_dir = "/".join([root, "results", "random-" + env_name, timestamp, str(os.getpid())])
        os.makedirs(log_dir)

        # Put executed command to the log 
        with open(log_dir + "/command.txt", "w") as txt:
            txt.write(" ".join(sys.argv))


        return log_dir

    @staticmethod
    def list2str(l):
        return " ".join([str(x) for x in l])

    @staticmethod
    def format_log(
        benchmark_uri: str, 
        observation_names: list,
        prev_observation: list, 
        observation: list, 
        action: str, 
        prev_actions: str, 
        reward: float,        
        ):
        
        prev_obs_ret = []
        obs_ret = []
        for i, obs_name in enumerate(observation_names):
            if obs_name.endswith("tensor"):
                prev_obs_ret.append(prev_observation[i].flat[:])
                obs_ret.append(observation[i].flat[:])
            elif obs_name.endswith("pickle"):
                prev_obs_ret.append(pickle.loads(prev_observation[i]))
                obs_ret.append(pickle.loads(observation[i]))

            else:
                logging.critical(f"FormatLog doesn't recognize Observation Type: {obs_name}")
                exit(1)

        return [benchmark_uri,
                prev_obs_ret,
                obs_ret,
                action,
                prev_actions,
                reward]


    def log_to_file(self):
        if len(self.log_list) == 0:
            return

        log_path = self.create_log_dir(self.env.spec.id)

        columns = ["BenchmarkName", "State", "NextState", "Action", "CommandLine", "Reward"]
        df = pd.DataFrame(self.log_list, columns=columns) 
        df.head()
        with open(log_path + '/results.pkl', 'wb') as f:
            pickle.dump(df, f)
        
        print("\nResults written to: ", log_path + "/results.pkl\n")
        # Clear the content
        self.log_list.clear()





from compiler_gym.util.registration import register
from compiler2_service.paths import COMPILER2_SERVICE_PY
from compiler2_service.agent_py.rewards import perf_reward, runtime_reward
from compiler_gym.envs.llvm.datasets import (
    AnghaBenchDataset,
    BlasDataset,
    CBenchDataset,
    CBenchLegacyDataset,
    CBenchLegacyDataset2,
    CHStoneDataset,
    CsmithDataset,
    NPBDataset,
)

from compiler2_service.agent_py.datasets import (
    hpctoolkit_dataset,
    poj104,
    fbgemm_dataset,
    poj104_small
)

from compiler_gym.util.runfiles_path import site_data_path
import importlib

# register perf session
def register_env(datasets):
    register(
        id="compiler2-v0",
        # Vladimir: llvm auto tuners need this class. AFAIK, for dumping the opt flags combination.
        entry_point=HPCToolkitCompilerEnv,
        # entry_point="compiler_gym.service.client_service_compiler_env:ClientServiceCompilerEnv",
        kwargs={
            "service": COMPILER2_SERVICE_PY,
            "rewards": [
                perf_reward.RewardTensor(),
                # runtime_reward.RewardTensor()
            ],
            "datasets": [
            #     CBenchDataset(site_data_path("llvm-v0")),
            #     CsmithDataset(site_data_path("llvm-v0")),
            #     CHStoneDataset(site_data_path("llvm-v0")),
            #     hpctoolkit_dataset.Dataset(),
            #     poj104.Dataset(),
            #     poj104_small.Dataset(),
            #     fbgemm_dataset.Dataset()
                importlib.import_module(f"compiler2_service.agent_py.datasets.{dataset}").Dataset() for dataset in datasets 
            ],
        },
    )
# register_env()

def set_globals(datasets, max_episode_steps):
    global datasets_global, max_episode_steps_global
    datasets_global, max_episode_steps_global = datasets, max_episode_steps

def get_globals():
    global datasets_global, max_episode_steps_global
    return datasets_global, max_episode_steps_global
    


def make(id: str, datasets, **kwargs):
    """Equivalent to :code:`compiler_gym.make()`."""
    if len(datasets):
        register_env(datasets=datasets)

    import compiler_gym
    return compiler_gym.make(id, **kwargs)


def make_env(id, logging=False, **kwargs):
    return HPCToolkitCompilerEnvWrapper(make(id, **kwargs), logging=logging)


