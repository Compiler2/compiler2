"""This module defines and registers the example gym environments."""
from pathlib import Path

from compiler_gym.util.runfiles_path import runfiles_path, site_data_path


from compiler_gym.envs.compiler_env import CompilerEnv
from compiler_gym.spaces import Commandline, CommandlineFlag
from compiler_gym.service.proto import Space, proto_to_action_space, CommandlineSpace
from typing import cast, List, Union, Optional
import os
import shutil

def convert_commandline_space_message(message: CommandlineSpace) -> Commandline:
    # Copied from CompilerGym and adapted.
    return Commandline(
        items=[
            CommandlineFlag(name=name, flag=name, description="")
            for name in message.space.named_discrete.name
        ],
        name=None,
    )


class HPCToolkitCompilerEnv(CompilerEnv):
    """
    The below functions are copied from LlvmEnv
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if len(self.service.action_spaces) != 1:
            raise Exception("Vladimir: Not supporting more than one")
        # Vladimir: I need to force conversion to CommandlineSpace
        self.action_spaces = [
            convert_commandline_space_message(self.service.action_spaces[0])
        ]
        # Vladimir: Force action_space initialization
        # Without this it might not work
        self.action_space = ""

    def commandline(  # pylint: disable=arguments-differ
            self, textformat: bool = False
    ) -> str:
        """Returns an LLVM :code:`opt` command line invocation for the current
        environment state.

        :param textformat: Whether to generate a command line that processes
            text-format LLVM-IR or bitcode (the default).
        :returns: A command line string.
        """
        # For some reason, action space won't be changed to CommandlineSpace.
        # We're manually creating Commandline object.
        # This was the previous implementation that doesn't work.
        command = cast(Commandline, self.action_space).commandline(self.actions)
        if textformat:
            return f"opt {command} input.ll -S -o output.ll"
        else:
            return f"opt {command} input.bc -o output.bc"

    def commandline_to_actions(self, commandline: str) -> List[int]:
        """Returns a list of actions from the given command line.

        :param commandline: A command line invocation, as generated by
            :meth:`env.commandline() <compiler_gym.envs.LlvmEnv.commandline>`.
        :return: A list of actions.
        :raises ValueError: In case the command line string is malformed.
        """
        # Strip the decorative elements that LlvmEnv.commandline() adds.
        if not commandline.startswith("opt "):
            raise ValueError(f"Invalid commandline: `{commandline}`")
        if commandline.endswith(" input.ll -S -o output.ll"):
            commandline = commandline[len("opt "): -len(" input.ll -S -o output.ll")]
        elif commandline.endswith(" input.bc -o output.bc"):
            commandline = commandline[len("opt "): -len(" input.bc -o output.bc")]
        else:
            raise ValueError(f"Invalid commandline: `{commandline}`")
        return self.action_space.from_commandline(commandline)

    # def fork(self):
    #     ret = super().fork()
    #     return ret

    def write_bitcode(self, path: Union[Path, str]) -> Path:
        """Write the current program state to a bitcode file.

        :param path: The path of the file to write.
        :return: The input :code:`path` argument.
        """
        path = Path(path).expanduser()
        # FIXME vi3: We don't support this observation spaces.
        #   I guess we could just return the pickled content of the bitcode file
        tmp_path = self.observation["BitcodeFile"]
        try:
            shutil.copyfile(tmp_path, path)
        finally:
            os.unlink(tmp_path)
        return path


from compiler_gym.util.registration import register
from compiler2_service.paths import COMPILER2_SERVICE_PY
from compiler2_service.agent_py.rewards import perf_reward, runtime_reward
from compiler_gym.envs.llvm.datasets import (
    AnghaBenchDataset,
    BlasDataset,
    CBenchDataset,
    CBenchLegacyDataset,
    CBenchLegacyDataset2,
    CHStoneDataset,
    CsmithDataset,
    NPBDataset,
)

from compiler2_service.agent_py.datasets import hpctoolkit_dataset
from compiler2_service.agent_py.datasets import poj104_dataset

from compiler_gym.util.runfiles_path import site_data_path

# register perf session
register(
    id="perf-v0",
    # Vladimir: llvm auto tuners need this class. AFAIK, for dumping the opt flags combination.
    entry_point=HPCToolkitCompilerEnv,
    kwargs={
        "service": COMPILER2_SERVICE_PY,
        "rewards": [
            perf_reward.Reward(),
            runtime_reward.Reward()
        ],
        "datasets": [
            CBenchDataset(site_data_path("llvm-v0")),
            CsmithDataset(site_data_path("llvm-v0")),
            CHStoneDataset(site_data_path("llvm-v0")),
            hpctoolkit_dataset.Dataset(),
            poj104_dataset.Dataset(),
        ],
    },
)


def make(id: str, **kwargs):
    """Equivalent to :code:`compiler_gym.make()`."""
    import compiler_gym
    return compiler_gym.make(id, **kwargs)
